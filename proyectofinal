#include <stdio.h>
#include <string.h>
#include <conio.h>
#include <stdlib.h>
#include <time.h>
#include <math.h>
#include <SDL2/SDL.h>
#include <SDL2/SDL_ttf.h>

// PROTOTIPADO DE FUNCIONES
void clear();
void inicio();
void crear_us(char us[]);
void menu(char us[]);
int bus_us(char nom[]);
void newfiles();
void encriptacion(char contra[]);
void login(int); 
void borrar_us();
void tabla_val(long int x[30], long int y[30], int min, int max, int inc, char pol[20], char us[30],int opc);
void polinomio(char us[30],int mini, int maxi, int incre, int opc, char polin[20]);
void fech(char time[30]);
void borr_gra(char us[30]);
void list_acc(char us[30]);
void cam_pass(char us[30]);
void list(char us[30]);
void cam_pass_us();
void cam_pass_SU();
void graf_ref();
void graf_ref_us(char us[30]);
void graficadora(long int valorx[80], long int valory[80], int k, int rangoinicial, int rangofinal, int incremento);
void password(char contra[30]);
void list_all();

//estructura para el grafico
typedef struct
{
    char us[30];
    char poli[20];
    char tim[30];
    int ref,min,max,inc;
    int control;
}graf;

//estructura para el login
typedef struct
{
    char nom[30];
    char cont[30];
    char control;
} log_in;

//funcion para pedir la contraseÃ±a
void password(char contra[30])
{
    char val=0; //val para guardar cada caracter
    int cont1=0;
    memset(contra,0,30);
    fflush(stdin);
    for (int i = 0; i <= 29; i++)
    {
        fflush(stdin);
        val = getch(); //lectura del caracter por teclado

        if (val == 13 && cont1 >= 4)
        {
            contra[i + 1] = 00; //cerrando cadena
            i = 50;
        }
        else if (val == 29);
        else if (val != 13 && val >= 32)
        {
            contra[i] = val; //guardando posicion a posicion
            printf("*");
            cont1++;
        }
        val = 0; //reiniciando el caracter
    }

    return;
}
void graficadora(long int valorx[80], long int valory[80], int k, int rangoinicial, int rangofinal, int incremento)
{
    //codigo para abrir la ventana en maximo 
    SDL_Init( SDL_INIT_EVERYTHING );
    int window_width=0,window_height=0;
    SDL_Window *sdl_window=NULL;
    sdl_window = SDL_CreateWindow("title", 10, 30, window_width, window_height, SDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE);
    SDL_MaximizeWindow(sdl_window);
    SDL_GetWindowSize(sdl_window, &window_width, &window_height);
    SDL_Quit( );

    SDL_Window *window = NULL; //Creamos un puntero de una ventana
    SDL_Renderer *paintbrush = NULL; //Creamos un puntero de renderer que va a ser el pincel
    long int ejey = 0; //Va a guardar el valor del pixel donde se va atrazar el eje de las 'y'
    long int ejex = 0; //Va a guardar el valor del pixel donde se va atrazar el eje de las 'x'
    
    char band = 'V'; //Para saber cuando cerrar la ventana
    const int WIDTH = window_width-40, HEIGHT = window_height-40; //Declaramos dos enteros, el ancho y largo de la ventana
    
    SDL_Init(SDL_INIT_EVERYTHING); //Inicia todo los sistemas de graficos de sdl, para poder utilizarlos
    TTF_Init(); //iniciamos la libreria de fuentes
    //Parametros que tiene la ventana, los dos primeros son por defecto, luego esta el ancho y la altura, y el ultimo muestra la ventana en la pantalla
    window = SDL_CreateWindow("Grafica", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, WIDTH, HEIGHT, SDL_WINDOW_SHOWN); 

    paintbrush = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED); //Parametros del renderer

    TTF_Font *font=TTF_OpenFont("simple_s.ttf",16); //abrimos la fuente
    SDL_Color color = {255,255,255}; //seleccionamos un color para las fuentes
        
    SDL_Surface *sur = NULL; //creamos un puntero de superficie
  
    SDL_Texture *text = NULL; //creamus una textura


    int maxx=valorx[k-1],minx=valorx[0]; //buscamos el valor maximo en 'x' y en 'y'
    int valy=0; //creamos un entero para almacenar el valor mayor en 'y' con valor absoluto
    if (abs(valorx[0]) < abs(rangofinal)) //si el valor del primero es menor que el rango final
        maxx = abs(rangofinal);
    else //de lo contrario
        maxx = abs(valorx[0]);
    
    for (int w = 0; w <= k - 1; w++) 
        if (abs(valory[w]) > abs(valy)) //si el valor es mayor que el almacenado
            valy = abs(valory[w]);

    long int miny=100000, maxy=-100000; //miny para almacenar el valor minimo en 'y' y maxy para almacenar el valor maximo en 'y'
    
    //for para almacenar el minimo y el maximo en 'y'
    for(int i=0;i<=k-1;i++)
    {
        if(valory[i]<miny)
            miny=valory[i];
        
        if(maxy<valory[i])
            maxy=valory[i];
    }

    int nx=0,ny=0; //nx para almacenar el numero de datos en 'x' y ny para almacenar el numero de datos en 'y'

    // contador de valores en x
    for(int i=rangoinicial;i<=rangofinal;i++)
        nx++;
    
    //  contador de valores en y
    for(int i=miny;i<=maxy;i++)
        ny++;
    
    float ajustex=0, ajustey=0; //ajustex para almacenar el valor correspondiente a cada valor en x y lo mismo para 'y'

                        
    int difx0=0;  //difx0 para contar la diferencia entre el numero mas cercano a 0 en x y el 0
    int dify0=0; //dify0 para contar la diferencia entre el numero mas cercano a 0 en x y el 0


    //contamos la diferencia
    if(valorx[k-1]<0)
        for(int i=valorx[k-1];i<0;i++)
            difx0++;
    else if(valorx[0] > 0)
        for(int i=valorx[0];i>0;i--)
            difx0++;

    if(maxy<0)
        for(int i=maxy;i<=0;i++)
            dify0++;
    else if(miny > 0)
        for(int i=miny;i>=0;i--)
            dify0++;
    

    ajustey=(HEIGHT*1.0)/((ny+dify0)*1.0); //calculamos el valor para cada dato de y
    
    ajustex=(WIDTH*1.0)/((nx+difx0)*1.0); //calculamos el valor para cada dato de x

    int n0x=0,n0y=0;

    for (int i=valorx[0];i<=0;i++)
    {
        n0x++;
    }

    for (int i=miny;i<=0;i++)
    {
        n0y++;
    }

    //calculamos el eje de y
    if(miny < 0 && maxy > 0)
    {
        if(n0y%2 == 0 && n0y!=2)
            ejey= ajustey * n0y;
        else
            ejey= (ajustey * n0y) - (ajustey/2);
    }
    else if(miny<0)
    {
        ejey= HEIGHT - 30;
    }
    else
    {
        ejey=30;
    }

    //calculamos el eje de x
    if(valorx[0]<0 && valorx[k-1]>0)
    {
        if(n0x%2 == 0 && n0x!=2)
            ejex= ajustex * n0x;
        else
            ejex= (ajustex * n0x) - (ajustex/2) ;
    }
    else if(valorx[0]<0 && valorx[k-1]<=0)
    {
        ejex= WIDTH-30;
    }
    else
    {
        ejex=30;
    }

    //le restamos el valor al alto
    ejey=HEIGHT-ejey;

    
    //imprimimos los ejes
    SDL_SetRenderDrawColor(paintbrush,0,0,0,SDL_ALPHA_OPAQUE);
    SDL_RenderClear(paintbrush);
    SDL_SetRenderDrawColor(paintbrush,255,255,255,SDL_ALPHA_OPAQUE);
    SDL_RenderDrawLine(paintbrush,0,ejey,WIDTH,ejey);
    SDL_RenderPresent(paintbrush);
    SDL_RenderDrawLine(paintbrush,ejex,0,ejex,HEIGHT);
    SDL_RenderPresent(paintbrush);
    
    //creamos un rectangulo para el texto
    SDL_Rect Rectangle;

    Rectangle.w=10;
    Rectangle.h=10;

    char miniy[30]="",maxiy[30]="";//miniy para almacenar el valor minimo de y, maxiy para almacenar el valor maximo en y
    char minix[30]="",maxix[30]="";//minix para almacenar el valor minimo de y, maxix para almacenar el valor maximo en y

    int text_miny=0,text_maxy=0; //text_miny para almacenar la altura del texto minimo y text_maxy para almacenar la altura del valor mayor en y
    int pto_y=0, pto_y2=0,pto_x=0,pto_x2=0; //variables para guardar los puntos de origen y destino en X y Y

    for (int pos = 0; pos <= k-2; pos++) 
    {
        if(valory[pos]==miny) //si es igual al numero menor guardo la posicion para imprimir el numero
        {
            if(valory[pos]<0 || valory[pos] > 0)
            {
                if(valory[pos]<0)
                    text_miny= ejey + ((abs(valory[pos]))*ajustey); //pto_y= ejey + ((abs(valory[pos])- dify0 )*ajustey);
                else
                    text_miny= ejey - ((valory[pos])*ajustey); //pto_y= ejey - ((valory[pos] -dify0)*ajustey);
            } 
            else
                text_miny=ejey;
        }
        if(valory[pos+1]==maxy) //si es igual al numero mayor guardo la posicion para imprimir el numero
        {
            if(valory[pos+1]<0 || valory[pos+1] > 0)
            {
                if(valory[pos+1]<0)
                    text_maxy= ejey + ((abs(valory[pos+1]))*ajustey); //pto_y2= ejey + ((abs(valory[pos+1])- dify0)*ajustey);
                else
                    text_maxy= ejey - ((valory[pos+1])*ajustey); //pto_y2= ejey - ((valory[pos+1]- dify0)*ajustey);
            } 
            else
                text_maxy=ejey;
        }
        if(valorx[pos]<0 || valorx[pos] > 0) //sino es 0
        {
            if(valorx[pos]<0)
                pto_x= ejex - ((abs(valorx[pos]))*ajustex); //pto_x= ejex - ((abs(valorx[pos])-difx0)*ajustex);
            else
                pto_x= ejex + ((valorx[pos])*ajustex); //pto_x= ejex + ((valorx[pos]-difx0)*ajustex);
        } 
        else //si es 0
        {
            //if(valorx[0]<0 && valorx[k-1]<0)
            //    pto_x=ejex + (ajustex*difx0);
            //else if(valorx[0]>0 && valorx[k-1]>0)
            //    pto_x=ejex - (ajustex*difx0);
            //else
                pto_x=ejex;
        }

        if(valorx[pos+1]<0 || valorx[pos+1] > 0) //sino es 0
        {
            if(valorx[pos+1]<0)
                pto_x2= ejex - ((abs(valorx[pos+1]))*ajustex); //pto_x2= ejex - ((abs(valorx[pos+1])-difx0)*ajustex);
            else
                pto_x2= ejex + ((valorx[pos+1])*ajustex);//pto_x2= ejex + ((valorx[pos]-difx0)*ajustex);
        } 
        else //si es 0
        {
         //   if(valorx[0]<0 && valorx[k-1]<0)
           //     pto_x2=ejex + (ajustex*difx0);
           // else if(valorx[0]>0 && valorx[k-1]>0)
             //   pto_x2=ejex - (ajustex*difx0);
            //else
                pto_x2=ejex;
        }
        if(valory[pos]<0 || valory[pos] > 0) //sino es 0
        {
            if(valory[pos]<0)
                pto_y= ejey + ((abs(valory[pos]))*ajustey); //pto_y= ejey + ((abs(valory[pos])- dify0 )*ajustey);
            else
                pto_y= ejey - ((valory[pos])*ajustey); //pto_y= ejey - ((valory[pos] -dify0)*ajustey);
        } 
        else //si es 0  
        {
           // if(miny<0 && maxy<0)
            //    pto_y=ejey + (ajustey*dify0);
            //else if(miny>0 && maxy>0)
              //  pto_y=ejey - (ajustey*dify0);
           // else
                pto_y=ejey;
        }

        if(valory[pos+1]<0 || valory[pos+1] > 0) //si es mayor o menor que 0
        {
            if(valory[pos+1]<0)
                pto_y2= ejey + ((abs(valory[pos+1]))*ajustey); //pto_y2= ejey + ((abs(valory[pos+1])- dify0)*ajustey);
            else
                pto_y2= ejey - ((valory[pos+1])*ajustey); //pto_y2= ejey - ((valory[pos+1]- dify0)*ajustey);
        } 
        else //si es 0
        {
            //if(miny<0 && maxy<0)
             //   pto_y2=ejey + (ajustey*dify0);
            //else if(miny>0 && maxy>0)
             //   pto_y2=ejey - (ajustey*dify0);
            //else
                pto_y2=ejey;
        }

        SDL_SetRenderDrawColor(paintbrush,138, 43, 226,SDL_ALPHA_OPAQUE);
        
        //imprimimos la linea
        SDL_RenderDrawLine(paintbrush,pto_x,pto_y,pto_x2,pto_y2);
        SDL_RenderPresent(paintbrush);
        
        //lineas de punto en x
        SDL_SetRenderDrawColor(paintbrush,238, 130, 238,SDL_ALPHA_OPAQUE);
        SDL_RenderDrawLine(paintbrush,pto_x,ejey-4,pto_x,ejey+4);
        SDL_RenderPresent(paintbrush);

        //lineas de punto en y
        SDL_RenderDrawLine(paintbrush,ejex-4,pto_y,ejex+4,pto_y);
        SDL_RenderPresent(paintbrush);

        SDL_Color color1 = {0,255,255};
        sur = TTF_RenderText_Solid(font,"x",color1);
        text = SDL_CreateTextureFromSurface(paintbrush,sur);
        Rectangle.w=10;
        Rectangle.h=10;
        Rectangle.x=pto_x-3;
        Rectangle.y=pto_y-5;
        SDL_RenderCopy(paintbrush,text,0,&Rectangle);
        SDL_RenderPresent(paintbrush);
    }
    //imprimimos la ultima linea
    SDL_SetRenderDrawColor(paintbrush,238, 130, 238,SDL_ALPHA_OPAQUE);
    SDL_RenderDrawLine(paintbrush,pto_x2,ejey-4,pto_x2,ejey+4);
    SDL_RenderPresent(paintbrush);
    SDL_RenderDrawLine(paintbrush,ejex-4,pto_y2,ejex+4,pto_y2);
    SDL_RenderPresent(paintbrush);
    
    //imprimir la ultima x
    Rectangle.w=10;
    Rectangle.h=10;
    Rectangle.x=pto_x2-3;
    Rectangle.y=pto_y2-5;
    SDL_RenderCopy(paintbrush,text,0,&Rectangle);
    SDL_RenderPresent(paintbrush);

    SDL_SetRenderDrawColor(paintbrush,255,0,0,SDL_ALPHA_OPAQUE);
    
    //imprimimos el valor maximo en X
    itoa(valorx[0],maxix,10);
    if(valorx[0]<0)
        pto_x= ejex - ((abs(valorx[0]))*ajustex);
    else
        pto_x= ejex + ((valorx[0])*ajustex);

    sur = TTF_RenderText_Solid(font,maxix,color);
    text = SDL_CreateTextureFromSurface(paintbrush,sur);
    Rectangle.w=15;
    Rectangle.h=10;
    if(ejey > HEIGHT-20)
    {
        Rectangle.x=pto_x;
        Rectangle.y=ejey-10;
    }
    else
    {
        Rectangle.x=pto_x;
        Rectangle.y=ejey+10;
    }

    SDL_SetRenderDrawColor(paintbrush,0,0,0,SDL_ALPHA_OPAQUE);

    SDL_RenderCopy(paintbrush,text,0,&Rectangle);

    SDL_RenderPresent(paintbrush);

    //imprimimos el valor minimo en X
    itoa(valorx[k-1],minix,10);
    if(valorx[k-1]<0)
        pto_x= ejex - ((abs(valorx[k-1]))*ajustex);
    else
        pto_x= ejex + ((valorx[k-1])*ajustex);
    sur = TTF_RenderText_Solid(font,minix,color);
    text = SDL_CreateTextureFromSurface(paintbrush,sur);
    Rectangle.w=15;
    Rectangle.h=10;
    if(ejey > HEIGHT-20)
    {
        Rectangle.x=pto_x;
        Rectangle.y=ejey-10;
    }
    else
    {
        Rectangle.x=pto_x;
        Rectangle.y=ejey+10;
    }

    SDL_SetRenderDrawColor(paintbrush,0,0,0,SDL_ALPHA_OPAQUE);

    SDL_RenderCopy(paintbrush,text,0,&Rectangle);

    SDL_RenderPresent(paintbrush);

    if(text_maxy!=text_miny)
    {
        //imprimimos el valor minimo en y
        itoa(miny,miniy,10);
        sur = TTF_RenderText_Solid(font,miniy,color);
        text = SDL_CreateTextureFromSurface(paintbrush,sur);
        Rectangle.w=15;
        Rectangle.h=10;
        Rectangle.x=ejex-20;
        Rectangle.y=text_miny;
        SDL_SetRenderDrawColor(paintbrush,0,0,0,SDL_ALPHA_OPAQUE);

        SDL_RenderCopy(paintbrush,text,0,&Rectangle);

        SDL_RenderPresent(paintbrush);
    }
    
    if(text_maxy!=text_miny)
    {
        //imprimimos el valor maximo en y
        itoa(maxy,maxiy,10);
        sur = TTF_RenderText_Solid(font,maxiy,color);
        text = SDL_CreateTextureFromSurface(paintbrush,sur);
        Rectangle.w=15;
        Rectangle.h=10;
        Rectangle.x=ejex-20;
        Rectangle.y=text_maxy;
        SDL_SetRenderDrawColor(paintbrush,0,0,0,SDL_ALPHA_OPAQUE);

        SDL_RenderCopy(paintbrush,text,0,&Rectangle);

        SDL_RenderPresent(paintbrush);
    }
    
    SDL_Event e; //Recibe evento de la ventana, (Mouse o Teclado)

    //Para cerrar la ventana
    while(band == 'V'){

        if(SDL_PollEvent(&e)){ //estÃ¡ recibiendo notificaciones de eventos segun el orden que ocurrieron.

            switch(e.type){ //Tipo de evento

                case SDL_QUIT: //Cerrar ventana dandole a la 'X'
                        band = 'F';
                        break; 
            }
            
        }
    }

    SDL_DestroyWindow(window); //Destruimos nuestra ventana para liberar la memoria
    SDL_DestroyRenderer(paintbrush); //Destruimos nuestro renderer para liberar memoria
    TTF_CloseFont(font); //cerramos la fuente
    SDL_Quit();  //quita el SDL

  return;

}
void graf_ref_us(char us[30])
{
    FILE *fp = fopen("logs.txt", "rb"); //abrimos el archivo
    graf reg; //creamos un dato de tipo graf para almacenar el registro
    fseek(fp, 0, SEEK_END); //nos paramos en el final
    int n = ftell(fp) / sizeof(graf); //calcular el numero de registros
    rewind(fp); //reiniciamos el puntero
    int refer = 0; //para guardar la referencia a buscar
    int flag = 0; //variable de tipo bandera

    clear();
    printf("        Aplicativo - Graficador UTP\n\n");
    printf("Impresion de grafico por referencia - usuario: %s\n\n", us);
    
    printf("Entre Nro (referencia): ");
    fflush(stdin); 
    scanf("%i", &refer); //leer la referencia por teclado
    for (int i = 0; i <= n - 1; i = i + 1)
    {
        fread(&reg, sizeof(graf), 1, fp); //leemos cada registro

        if (strcmp(us, reg.us) == 0 && reg.ref == refer && reg.control == 0) //si es el mismo usuario, la misma referencia y no esta borrado
        {
            printf("Username: %s Fecha: %s\nf(x): %s Rango: %i a %i Incremento: %i\n", reg.us, reg.tim, reg.poli, reg.min, reg.max, reg.inc);
            flag = 1;
            printf("Presiona una tecla para imprimir grafico...");
            getch();
            polinomio(reg.us,reg.min,reg.max,reg.inc,1,reg.poli); //llamamos al polinomio para el modo grafico
        }
        else if (strcmp(us, reg.us) != 0 && reg.ref == refer && reg.control == 0)
            flag = 2;
    }

    if (flag == 0) //si el grafico no existe
    {
        printf("EL GRAFICO NO EXISTE...");
        getch();
    }
    else if (flag == 2)//si el grafico no es suyo
    {
        printf("EL GRAFICO NO ES SUYO...");
        getch();
    }

    fclose(fp);

    return;
}
void graf_ref()
{
    FILE *fp = fopen("logs.txt", "rb"); //abrimos el archivo
    graf reg; //creamos un dato de tipo graf
    fseek(fp, 0, SEEK_END); //nos paramos en el final
    int n = ftell(fp) / sizeof(graf); //almacenar el numero de registros
    rewind(fp); //reiniciamos el puntero
    int refer = 0; //para almacenar la referencia
    int flag = 0; //variable tipo bandera

    clear();
    printf("        Aplicativo - Graficador UTP\n\n");
    printf("Impresion de grafico por referencia \n\n");

    printf("Entre Nro (referencia): ");
    fflush(stdin);
    scanf("%i", &refer); //leemos la referencia por teclado

    for (int i = 0; i <= n - 1; i = i + 1)
    {
        fflush(stdin);
        fflush(stdout);
        fread(&reg, sizeof(graf), 1, fp); //leemos cada registro

        if (reg.ref == refer && reg.control == 0) //si la referencia es igual y no esta borrado
        {
            printf("Username: %s Fecha: %s\nf(x): %s Rango: %i a %i Incremento: %i\n", reg.us, reg.tim, reg.poli, reg.min, reg.max, reg.inc);
            flag = 1;
            printf("Presiona una tecla para imprimir grafico...");
            getch();
            polinomio(reg.us,reg.min,reg.max,reg.inc,1,reg.poli); //llamamos al polinomio para el modo grafico
        }
    }

    if (flag == 0) //si el grafico no existe
    {
        printf("EL GRAFICO NO EXISTE...");
        getch();
    }

    fclose(fp);

    return;
}
void cam_pass_us()
{
    FILE *fp = fopen("login.txt", "rb"); //abrimos el archivo
    FILE *fp1 = fopen("auxiliar.txt", "w"); //creamos un archivo
    log_in reg; //variable de tipo log_in
    fseek(fp, 0, SEEK_END);//me paro en el final
    int n = ftell(fp) / sizeof(log_in); //n para el numero de registros
    rewind(fp); //reinciamos el puntero
    char c1[30] = "", c2[30] = "", nom[30] = ""; //c1 para la primera clave, c2 para la segunda clave,nom para almacenar el nombre

    clear();
    printf("        Aplicativo - Graficador UTP\n\n");
    printf("Menu para cambiar password de un usuario\n\n");

    printf("Ingresa el nombre del usuario: ");
    fflush(stdin);
    scanf("%s", nom); //leemos el nombre por teclado

    int flag = bus_us(nom); //buscamos el usuario

    if (flag != -1) //si el usuario existe
    {
        for (int i = 0; i <= n - 1; i++)
        {
            fread(&reg, sizeof(log_in), 1, fp); //leemos cada registro

            if (strcmp(nom, reg.nom) == 0 && reg.control == '0') //si el nombre es igual y no esta borrado
            {
                printf("\nIngresa tu nuevo password: ");
                password(c1); //leemos la clave
                printf("\nIngresa tu password de nuevo: ");
                password(c2); //leemos la clave

                if (strcmp(c1, c2) != 0) //si son diferentes
                {
                    printf("\nLAS PASSWORDS NO COINCIDEN...");
                    getch();
                    fclose(fp);
                    return;
                }
                else //si son iguales
                {
                    encriptacion(c1); //encriptamos la clave
                    fwrite(reg.nom, sizeof(reg.nom), 1, fp1);
                    fwrite(c1, sizeof(c1), 1, fp1);
                    fwrite(&reg.control, sizeof(reg.control), 1, fp1);
                }
            }
            else
            {
                fwrite(&reg, sizeof(log_in), 1, fp1); //escribimos todo el registro
            }
        }

        fclose(fp); //cerramos el archivo
        fclose(fp1); //cerramos el archivo
        rewind(fp); //reinciamos el puntero
        rewind(fp1); //reinciamos el puntero

        fp = fopen("auxiliar.txt", "rb"); //abrimos el archivo
        fp1 = fopen("login.txt", "w"); //sobreescribimos el archivo

        for (int j = 0; j <= n - 1; j++)
        {
            fread(&reg, sizeof(log_in), 1, fp); //leemos el registro
            fwrite(&reg, sizeof(log_in), 1, fp1); //escribimos el registro 
        }

        printf("\nPASSWORD CAMBIADA....");
        getch();
    }
    else
    {
        printf("\nEL USUARIO NO EXISTE....");
        getch();
    }

    fclose(fp); //cerramos el archivo
    fclose(fp1); //cerramos el archivo

    return;
}
void list(char us[30])
{
    graf reg; //creamos una variable de tipo reg
    FILE *fp = fopen("logs.txt", "rb"); //abrimos el archivo
    fseek(fp, 0, SEEK_END); //nos paramos en el final
    int tot = ftell(fp) / sizeof(graf); //calculamos el numero de registros
    int cont = 0; //para contar el numero de registros
    rewind(fp); //reiniciamos el puntero

    printf("\nUsername: %s\n\n", us);

    printf("Fecha           Nro grafico         Polinomio f(x)\n");
    printf("--------------------------------------------------\n");

    for (int i = 0; i <= tot - 1; i = i + 1)
    {
        fread(&reg, sizeof(graf), 1, fp); //leemos el registro

        if (strcmp(us, reg.us) == 0 && reg.control == 0) //si el usuario es igual y no esta borrado
        {
            printf("%s      %i     %20s\n", reg.tim, reg.ref, reg.poli);
            cont = cont + 1;
        }
    }
    printf("***************************************************\n");
    if (cont == 0)
        printf("NO EXISTEN REGISTROS\n");
    else
        printf("%4i     registros\n", cont);

    fclose(fp); //cerramos el archivo

    return;
}
void list_all()
{
    FILE *fp = fopen("login.txt", "rb"); //abrimos el archivo
    log_in reg; //variable de tipo log_in 
    int flag=0; //variable de tipo bandera
    fseek(fp, 0, SEEK_END); //nos paramos al final
    int n = ftell(fp) / sizeof(log_in); //numero de registros
    rewind(fp); //reinciamos el puntero
    clear();
    printf("        Aplicativo - Graficador UTP\n\n");
    printf("Listado de accesos todos los usuarios \n\n");
    for (int i = 0; i <= n - 1; i++)
    {
        fread(&reg, sizeof(log_in), 1, fp); //leemos los registros
        if (strcmp(reg.nom, "root") != 0 && reg.control == '0') //sino es root y no esta borrado
        {
            list(reg.nom); //llamamos la funcion
            flag=1;
        }
    }
    if(flag==0)
        printf("NO EXISTE NINGUN USUARIO....");
    getch();

    return;
}
void cam_pass_SU()
{
    
    FILE *fp = fopen("login.txt", "rb"); //abrimos el archivo
    FILE *fp1 = fopen("auxiliar.txt", "wb"); //abrimos el archivo
    log_in reg; //variable de tipo log_in //variable de tipo log_in para los registros
    fseek(fp, 0, SEEK_END); //nos paramos al final
    int n = ftell(fp) / sizeof(log_in), cont1 = 0; //numero de registros
    rewind(fp); //reiniciamos el puntero
    char c1[30] = "", c2[30] = "", nom[30] = ""; //c1 para contraseÃ±a 1 y c2 para contraseÃ±a 2, nom para almacenar el nombre
    clear();
    printf("        Aplicativo - Graficador UTP\n\n");
    printf("Menu para cambiar password de usuario root\n\n");

    printf("\nIngresa tu nuevo password: ");
    password(c1); //leemos la contraseÃ±a
    printf("\nIngresa tu password de nuevo: ");
    password(c2); //leemos la contraseÃ±a
    if (strcmp(c1, c2) != 0) //sino son iguales
    {
        printf("\nLAS PASSWORDS NO COINCIDEN...");
        getch();
        fclose(fp); //cerramos el archivo
        return;
    }
    else
    {
        encriptacion(c2); //encriptamos la clave
        fread(&reg,sizeof(log_in),1,fp); //leemos el registro
        fwrite(reg.nom, sizeof(reg.nom), 1, fp1); //escribimos el nombre
        fwrite(c2, sizeof(c2), 1, fp1); //escribimos la contraseÃ±a
        fputc('0',fp1); //caracter de control
        for (int i = 0; i <= n - 2; i++)
        {
            fread(&reg, sizeof(log_in), 1, fp); //leemos el registro
            fwrite(&reg, sizeof(log_in), 1, fp1); //escribimos el registro
        }

        fclose(fp); //cerramos el archivo
        fclose(fp1); //cerramos el archivo
        rewind(fp); //reiniciamos el puntero
        rewind(fp1); //reiniciamos el puntero

        fp = fopen("auxiliar.txt", "rb"); //abrimos el archivo
        fp1 = fopen("login.txt", "wb"); //sobreescribimos el archivo

        for (int j = 0; j <= n - 1; j++)
        {
            fread(&reg, sizeof(log_in), 1, fp); //leemos el registro
            fwrite(&reg, sizeof(log_in), 1, fp1); //escribimos el registro
        }

        printf("\nPASSWORD CAMBIADA....");
        getch();
    }
    fclose(fp); //cerramos el archivo
    fclose(fp1); //cerramos el archivo

    return;
}
void cam_pass(char us[30])
{
    FILE *fp = fopen("login.txt", "rb"); //abrimos el archivo
    FILE *fp1 = fopen("auxiliar.txt", "w"); //creamos un archivo
    log_in reg; //variable de tipo log_in
    fseek(fp, 0, SEEK_END); //final del archivo
    int n = ftell(fp) / sizeof(log_in); //numero de registros
    rewind(fp); //reiniciamos puntero
    char c1[30] = "", c2[30] = "", ca[30] = ""; //c1 para contraseÃ±a 1, c2 para contraseÃ±a 2 y ca para contraseÃ±a anterior
    int flag = bus_us(us); //buscamos el usuario
    clear();
    printf("        Aplicativo - Graficador UTP\n\n");
    printf("Menu para cambiar password de usuario: %s\n\n", us);
    if (flag != -1)
    {

        printf("Ingresa tu password anterior: ");
        password(ca); //leemos contraseÃ±a
        encriptacion(ca); //encriptamos contraseÃ±a
        fseek(fp, flag * sizeof(log_in), SEEK_SET); //nos paramos en el registro
        fread(&reg, sizeof(log_in), 1, fp); //leemos el registro
        rewind(fp); //reiniciamos puntero
        if (strcmp(ca, reg.cont) == 0)
        {
            for (int i = 0; i <= n - 1; i++)
            {
                fread(&reg, sizeof(log_in), 1, fp); //leemos registro

                if (strcmp(us, reg.nom) == 0 && strcmp(ca, reg.cont) == 0 && reg.control == '0')
                {
                    printf("\nIngresa tu nuevo password: ");
                    password(c1); //leemos password
                    printf("\nIngresa tu password de nuevo: ");
                    password(c2); //llemos password

                    if (strcmp(c1, c2) != 0)
                    {
                        fclose(fp);
                        printf("\nLAS PASSWORDS NO COINCIDEN...");
                        getch();
                        return;
                    }
                    else
                    {
                        encriptacion(c1); //ecriptamos clave
                        fwrite(reg.nom, sizeof(reg.nom), 1, fp1);
                        fwrite(c1, sizeof(c1), 1, fp1);
                        fwrite(&reg.control, sizeof(reg.control), 1, fp1);
                    }
                }
                else
                {
                    fwrite(&reg, sizeof(log_in), 1, fp1); //escribimos el registro
                }
            }
        }
        else
        {
            printf("\nLA PASSWORD ES INCORRECTA...");
            getch();
            fclose(fp); //cerramos el archivo
            return;
        }

        fclose(fp);//cerramos el archivo
        fclose(fp1);//cerramos el archivo
        rewind(fp);//reiniciamos el puntero
        rewind(fp1);//reiniciamos el puntero

        fp = fopen("auxiliar.txt", "rb"); //abrimos el archivo
        fp1 = fopen("login.txt", "w"); //sobreescribimos el archivo

        for (int j = 0; j <= n - 1; j++)
        {
            fread(&reg, sizeof(log_in), 1, fp); //leemos el registro
            fwrite(&reg, sizeof(log_in), 1, fp1); //escribimos el registro
        }

        printf("\nPASSWORD CAMBIADA....");
        getch();
    }
    else
    {
        printf("\nEL USUARIO NO EXISTE....");
        getch();
    }

    fclose(fp); //cerramos el archivo
    fclose(fp1);//cerramos el archivo

    return;
}
void list_acc(char us[30])
{
    graf reg; //variable de tipo gra
    FILE *fp = fopen("logs.txt", "rb"); //abrimos el archivo
    fseek(fp, 0, SEEK_END); //nos paramos en el final
    int tot = ftell(fp) / sizeof(graf); //numero de registros
    int cont = 0; //contador
    int opc=0; //opcion
    rewind(fp); //reiniciamos el puntero
    clear();
    int flag = bus_us(us);
    printf("        Aplicativo - Graficador UTP\n\n");
    printf("Modulo listar accesos - Usuario: %s\n\n", us);
    printf("\n Ordenar por fecha. \nPresione(1) Orden ascendente (2) Orden Descendente:  ");
    fflush(stdin);
    scanf("%i",&opc); //leemos la opcion por teclado
    printf("Fecha           Nro grafico         Polinomio f(x)\n");
    printf("--------------------------------------------------\n");
    
    if (flag != -1)
    {
        if(opc==1) //forma ascendente
        {
            for (int i = 0; i <= tot - 1; i = i + 1)
            {
                fread(&reg, sizeof(graf), 1, fp); //leemos cada registro

                if (strcmp(us, reg.us) == 0 && reg.control == 0)
                {
                    printf("%s      %i     %20s\n", reg.tim, reg.ref, reg.poli);
                    cont = cont + 1;
                }
            }
            
        }
        else //forma descendente
        {
            for (int i = tot-1; i >=0; i = i - 1)
            {
                fseek(fp,sizeof(graf)*i,SEEK_SET);
                fread(&reg, sizeof(graf), 1, fp); //leemos el registro

                if (strcmp(us, reg.us) == 0 && reg.control == 0)
                {
                    printf("%s      %i     %20s\n", reg.tim, reg.ref, reg.poli);
                    cont = cont + 1;
                }
            }
        }   
    
        printf("***************************************************\n");
                if (cont == 0)
                    printf("NO EXISTEN REGISTROS");
                else
                    printf("%4i     registros", cont);

    }
    else
        printf("EL USUARIO NO EXISTE....");
    fclose(fp); //cerramos el archivo

    getch();

    return;
}
void borr_gra(char us[30])
{
    graf reg; //variable tipo graf
    FILE *fp = fopen("logs.txt", "rb"); //abrimos el archivo
    FILE *fp1 = fopen("auxiliar.txt", "wb"); //creamos el archivo
    fseek(fp, 0, SEEK_END); //final de archivo
    int tot = ftell(fp) / sizeof(graf); //numero de registros
    int flag = 0, referencia = 0; //bandera y referencia
    rewind(fp); //reinciamos el apuntador

    clear();
    printf("        Aplicativo - Graficador UTP\n\n");
    printf("Menu para borrar un grafico existente\n\n");
    printf("Ingresa el numero de referencia: ");
    fflush(stdin);
    scanf("%i", &referencia); //leemos la referencia

    for (int i = 0; i <= tot - 1; i = i + 1)
    {
        fread(&reg, sizeof(graf), 1, fp); //leemos cada registro

        if (reg.ref == referencia && strcmp(us, reg.us) == 0 && reg.control == 0)
        {
            fwrite(reg.us, 30, 1, fp1);
            fwrite(reg.poli, 20, 1, fp1);
            fwrite(reg.tim, 30, 1, fp1);
            fwrite(&reg.ref, 4, 1, fp1);
            fwrite(&reg.min, 4, 1, fp1);
            fwrite(&reg.max, 4, 1, fp1);
            fwrite(&reg.inc, 4, 1, fp1);
            reg.control = 1;
            fwrite(&reg.control, 4, 1, fp1); 
            printf("Grafico borrado...");
            flag = 1;
        }
        else if(reg.ref == referencia && strcmp(us, reg.us) != 0 && reg.control == 0)
            flag=2;
        else
        {
            fwrite(&reg, sizeof(graf), 1, fp1); //escribimos el registro
        }
    }
    fclose(fp);//cerramos el archivo
    fclose(fp1);//cerramos el archivo

    if (flag == 0)
    {
        printf("\nGrafico no existente...");
    }
    else if (flag == 2)
    {
        printf("\nEl grafico no es tuyo...");
    }

    fp = fopen("logs.txt", "wb"); //sobreescribimos el archivo
    fp1 = fopen("auxiliar.txt", "rb"); //abrimos el archivo

    for (int i = 0; i <= tot - 1; i++)
    {
        fread(&reg, sizeof(graf), 1, fp1); //leemos el registro
        fwrite(&reg, sizeof(graf), 1, fp); //escribimos el registro
    }

    getch();
    fclose(fp); //cerramos el archivo
    fclose(fp1);//cerramos el archivo

    return;
}
void fech(char tim[30])
{
    time_t t = time(NULL);
    struct tm tiempoLocal = *localtime(&t);
    char fechaHora[70];
    // El formato.
    char *formato = "%Y-%m-%d";
    // Intentar formatear
    int bytesEscritos =
        strftime(fechaHora, sizeof fechaHora, formato, &tiempoLocal);

    strcpy(tim, fechaHora);

    return;
}
void tabla_val(long int x[30], long int y[30], int min, int max, int inc, char pol[20], char us[30],int opc)
{
    long int fy[80], fx[80]; //fx y fy para almacenar la tabla de valores
    long long int cont = 0, conty = 0; //contador de posicion
    long long int total = 0; //almacenar resultado de operacion
    long int coe = 0, exp = 0, bas = 0; //coeficiente, exponente y base para operacion
    int tot; //numero de registros
    char tim[30]; //almacenar fecha
    int n = 0, control = 0; //numero de datos y control de borrado
    for (int j = min; j <= max; j = j + inc)
    {
        n++;
    }

    FILE *fp = NULL; //apuntador de archivo
    graf reg; //variable de tipo graf
    fech(tim); //guardamos la fecha
    if(opc==0) 
    {
        fp = fopen("logs.txt", "rb"); //abrimos el archivo en modo lectura

        if (fp == 0)
            tot = 0;
        else
        {
            fseek(fp, 0, SEEK_END); //final del archivo
            tot = ftell(fp) / sizeof(graf); //numero de registros
        }
        fclose(fp); //cerramos el archivo
        rewind(fp); //reiniciamos el puntero
        fp = fopen("logs.txt", "ab"); //abrimos el archivo
        fwrite(us, 30, 1, fp);
        fwrite(pol, 20, 1, fp);
        fwrite(tim, 30, 1, fp);
        fwrite(&tot, 4, 1, fp);
        fwrite(&min, 4, 1, fp);
        fwrite(&max, 4, 1, fp);
        fwrite(&inc, 4, 1, fp);
        fwrite(&control, 4, 1, fp);
        fclose(fp); //cerramos el archivo
    }
    int aux=min;
    while (min <= max)
    {
        while (cont <= 19)
        {
            coe = x[cont];
            exp = y[cont];
            bas = min;
            total = total + (coe * (pow(bas, exp))); //operacion
            cont = cont + 1;
        }
        fy[conty] = total; //guardamos fy
        fx[conty] = min; //guardamos fx
        min = min + inc; //incrementamos al minimo
        total = 0;
        cont = 0;
        conty++;
    }
    if(opc==0)
    {
        //imprimimos tabla de valores
        printf("+------------------------------+\n");
        printf("|%10c      |%10c   |\n", 'X', 'Y');
        printf("+------------------------------+\n");
        for (int i = 0; i <= n - 1; i++)
        {
            printf("|%10ld      |   %10ld|\n", fx[i], fy[i]);
            printf("+------------------------------+\n");
        }
    }

    graficadora(fx,fy,n,aux,max,inc); //modo grafico

    return;
}
void polinomio(char us[30],int mini, int maxi, int incre, int opc, char polin[20])
{
    char num[10] = "", expo[10] = "", signo[10] = "";
    memset(num, 0, 10);
    memset(expo, 0, 10);
    memset(signo, 0, 10);
    
    char pol[20] = "";
    if(opc==0)
    {
        clear();
        printf("        Aplicativo - Graficador UTP\n\n");
        printf("Menu para crear un nuevo grafico\n\n", us);
        printf("Ingresa un polinomio: ");
        fflush(stdin);
        scanf("%s", pol); //leemos el polinomio
    }
    else
    {
        strcpy(pol,polin);
    }
    int min = 0, max = 0, incremento = 0, n = 0; 
    if(opc==0)
    {
        printf("Ingresa un rango inicial: ");
        fflush(stdin);
        scanf("%i", &min); //leemos el rango inicial
        printf("Ingresa un rango final: ");
        fflush(stdin);
        scanf("%i", &max); //leemos el rango final
        printf("Ingresa un incremento: ");
        fflush(stdin);
        scanf("%i", &incremento); //leemos el incremento
    }
    else
    {
        min=mini;
        max=maxi;
        incremento=incre;
    }
    for (int i = min; i <= max; i = i + incremento)
        n = n + 1; //numero de datos

    long int x[30] = {}, y[30] = {}; //coeficientes y exponentes
    long int j = 0, xp = 0, yp = 0, exp = 0, menos = 0, sp = 0;

    for (int i = 0; pol[i] != 00; i++)
    {
        if (pol[i] == 'X' || pol[i] == 'x')
        {
            if (pol[i - 1] == '-' || pol[i - 1] == '+' || num[0] == 0)
                num[0] = '1';

            if (menos == 1)
                x[xp] = atoi(num) * -1;
            else
                x[xp] = atoi(num);

            xp++;
            menos = 0;
            memset(num, 0, 10);
            j = 0;

            exp = 1;
        }
        else if (pol[i] == '(')
            ;
        else if (pol[i] == '+')
        {
            signo[sp] = pol[i];
            sp++;

            // if(pol[i-1]==')');
            if (pol[i - 1] == 'X' || pol[i - 1] == 'x')
                expo[0] = '1';

            else if (exp == 0 && expo[0] == 0)
            {
                if (menos == 1)
                    x[xp] = atoi(num) * -1;
                else
                    x[xp] = atoi(num);

                xp++;
                memset(num, 0, 10);
            }
            y[yp] = atoi(expo);
            yp++;
            memset(expo, 0, 10);
            j = 0;
            exp = 0;
            menos = 0;
        }
        else if (pol[i] == ')')
        {
            y[yp] = atoi(expo) * -1;
            yp++;
            memset(expo, 0, 10);
            j = 0;
            exp = 0;
            menos = 0;
        }
        else if (pol[i] == '-')
        {
            if (pol[i - 1] != '(' && i != 0)
            {
                signo[sp] = pol[i];
                sp++;
            }
            if (pol[i - 1] == 'X' || pol[i - 1] == 'x')
                expo[0] = '1';
            else if (pol[i - 1] == '(')
                expo[0] = '0';
            else if (exp == 0 && expo[0] == 0 && i != 0 && pol[i - 1] != '(')
            {
                expo[0] = '0';
                if (menos == 1)
                    x[xp] = atoi(num) * -1;
                else
                    x[xp] = atoi(num);

                xp++;
                memset(num, 0, 10);
            }
            if (i != 0 && pol[i - 1] != '(')
            {
                y[yp] = atoi(expo);
                yp++;
                memset(expo, 0, 10);
                j = 0;
                exp = 0;
            }
            menos = 1;
        }
        else if (pol[i] >= 48 && pol[i] <= 57)
        {
            if (exp == 0)
            {
                num[j] = pol[i];
                j++;
            }
            if (exp == 1)
            {
                expo[j] = pol[i];
                j++;
            }
        }

        if (pol[i + 1] == 0)
        {
            if (expo[0] == 0 && exp == 1) // si expo = 0 y hubo una x
            {
                expo[0] = '1'; // expo es igual a 1
            }
            else if (expo == 0 && expo[0] == 0)
                expo[0] = '0';
            if (pol[i] != ')') // si la ultima posicion (antes del cierre) es diferente de un )
            {
                if (menos == 1)
                    x[xp] = atoi(num) * -1;
                else
                    x[xp] = atoi(num);

                y[yp] = atoi(expo);
            }
        }
    }
    if(opc==0)
    {
        printf("\n f(x) = %s\n", pol);
        tabla_val(x, y, min, max, incremento, pol, us,0);
    }
    else
        tabla_val(x, y, min, max, incremento, pol, us,1);
    return;
}
void clear()
{
    if (system("cls"))   // Borra pantalla para S.O MS-Windows
        system("clear"); // Borra pantalla para S.O linux y/o MAC-OS
}
void borrar_us(char us[30])
{
    FILE *fp = fopen("login.txt", "rb"); //abrimos el archivo
    FILE *fp1 = fopen("auxiliar.txt", "w"); //creamos el archivo
    FILE *fp2 = fopen("logs.txt", "rb"); //abrimos el archivo
    FILE *fp3 = fopen("auxiliar1.txt", "w"); //creamos el archivo
    log_in registro; //variable de tipo log_in
    graf reg; //variable de tipo graf
    char name[30] = ""; //nombre
    fseek(fp, 0, SEEK_END); //final del archivo
    int tot = ftell(fp)/ sizeof(log_in); //numero de registros
    fseek(fp2, 0, SEEK_END); //final del archivo
    int n = ftell(fp2)/ sizeof(graf); //numero de registros
    int flag = 0; //bandera
    rewind(fp); //reiniciamos puntero
    rewind(fp2); //reiniciamos puntero

    clear();
    printf("        Aplicativo - Graficador UTP\n\n");
    printf("Menu para usuario: %s Borrar usuario\n\n", us);
    printf("Entre el usuario: \n");
    printf("Username: ");
    fflush(stdin);
    scanf("%s", name); //leemos el nombre
    if (strcmp(name, "root") == 0)
    {
        printf("NO SE PUEDE BORRAR EL USUARIO ROOT...");
        flag = -1;
    }
    else
        flag = bus_us(name); //buscamos el usuario

    if (flag != -1)
    {
        for (int i = 0; i <= tot - 1; i = i + 1)
        {
            fread(&registro, sizeof(log_in), 1, fp); //leemos cada registro

            if (strcmp(registro.nom, name) == 0 && registro.control == '0')
            {
                fwrite(registro.nom, sizeof(registro.nom), 1, fp1);
                fwrite(registro.cont, sizeof(registro.cont), 1, fp1);
                fputc('1', fp1);
                flag = -1;
            }
            else
            {
                fwrite(&registro, sizeof(log_in), 1, fp1); //escribimos el registro
            }
        }

        for (int i = 0; i <= n - 1; i = i + 1)
        {
            fread(&reg, sizeof(graf), 1, fp2); //leemos cada registro

            if (strcmp(reg.us, name) == 0 && reg.control == 0)
            {
                fwrite(reg.us, 30, 1, fp3);
                fwrite(reg.poli, 20, 1, fp3);
                fwrite(reg.tim, 30, 1, fp3);
                fwrite(&reg.ref, 4, 1, fp3);
                fwrite(&reg.min, 4, 1, fp3);
                fwrite(&reg.max, 4, 1, fp3);
                fwrite(&reg.inc, 4, 1, fp3);
                reg.control = 1;
                fwrite(&reg.control, 4, 1, fp3);
                flag = -1;
            }
            else
            {
                fwrite(&reg, sizeof(graf), 1, fp3); //escribimos el registro
            }
        }

        if (flag == -1)
            printf("\nUSUARIO BORRADO....");
        fclose(fp); //cerramos el archivo
        fclose(fp1); //cerramos el archivo
        fclose(fp2); //cerramos el archivo
        fclose(fp3); //cerramos el archivo

        fp = fopen("login.txt", "wb"); //sobreescribimos
        fp1 = fopen("auxiliar.txt", "rb"); //abrimos
        fp2 = fopen("logs.txt", "wb"); //sobreescribimos
        fp3 = fopen("auxiliar1.txt", "rb"); //abrimos
        for (int i = 0; i <= tot - 1; i++)
        {
            fread(&registro, sizeof(log_in), 1, fp1); //leemos el registro
            fwrite(&registro, sizeof(log_in), 1, fp); //escribimos el registro
        }
        for (int i = 0; i <= n - 1; i++)
        {
            fread(&reg, sizeof(graf), 1, fp3); //leemos el registro
            fwrite(&reg, sizeof(graf), 1, fp2); //escribimos el regitro
        }
    }
    else if (strcmp(name, "root") != 0)
    {
        printf("EL USUARIO NO EXISTE...");
    }

    getch();
    fclose(fp); //cerramos el archivo
    fclose(fp1);//cerramos el archivo
    fclose(fp2);//cerramos el archivo
    fclose(fp3);//cerramos el archivo

    return;
}
void crear_us(char us[30])
{
    FILE *fp = fopen("login.txt", "a"); //abrimos el archivo
    char name[30] = ""; //nombre
    char contra[30] = ""; //contraseÃ±a
    int flag = 0; //bandera
    do
    {
        clear();
        printf("        Aplicativo - Graficador UTP\n\n");
        printf("Menu para usuario: %s Crear nuevo usuario\n\n", us);
        printf("Entre el nuevo usuario: \n");
        printf("Username: ");
        fflush(stdin);
        scanf("%s", name); //leemos el nombre por teclado
        flag = bus_us(name); //buscamos el registro

        if (flag == -1)
        {
            printf("Password: ");
            password(contra); //leemos la contraseÃ±a
            encriptacion(contra); //encriptamos la contraseÃ±a
            fwrite(name, sizeof(name), 1, fp);
            fwrite(contra, sizeof(contra), 1, fp);
            fputc('0', fp);      
        }
        else
        {
            printf("EL USUARIO YA EXISTE...");
            getch();
        }
    } while (flag != -1);
    fclose(fp); //cerramos el archivo
    return;
}
void menu(char us[30])
{
    clear();
    char nom[30] = "", pol[20]=""; //nombre y polinomio
    int opc = 1; //opcion 1
    if (strcmp(us, "root") == 0) //menu para root
    {
        do
        {
            clear();
            printf("Aplicativo - Graficador UTP\n\n");
            printf("Menu principal para usuario: %s\n\n", us);
            printf("0. Salir del aplicativo\n");
            printf("1. Crear nuevo usuario\n");
            printf("2. Borrar usuario\n");
            printf("3. Listar accesos por usuarios\n");
            printf("4. Listar accesos todos los usuarios\n");
            printf("5. Imprimir grafico por referencia\n");
            printf("6. Cambiar password del usuario root\n");
            printf("7. Cambiar password de un usuario\n");
            fflush(stdin);
            scanf("%i", &opc);

            switch (opc)
            {
            case 0:
                break;
            case 1:
                crear_us(us);
                break;
            case 2:
                borrar_us(us);
                remove("auxiliar.txt");
                remove("auxiliar1.txt");
                break;
            case 3:
                clear();
                printf("        Aplicativo - Graficador UTP\n\n");
                printf("Listado de acceso por usuario\n\n");
                printf("Ingresa el usuario: ");
                scanf("%s", nom);
                list_acc(nom);
                strcpy(nom, "");
                break;
            case 4:
                list_all();
                break;
            case 5:
                graf_ref();
                break;
            case 6:
                cam_pass_SU();
                remove("auxiliar.txt");
                break;
            case 7:
                cam_pass_us();
                break;
            default:
                printf("OPCION INVALIDA...");
                getch();
            }
        } while (opc != 0);
    }
    else //menu para usuario
    {
        do
        {
            clear();
            printf("Aplicativo - Graficador UTP\n\n");
            printf("Menu principal para usuario: %s\n\n", us);
            printf("0. Salir del aplicativo\n");
            printf("1. Crear un nuevo grafico\n");
            printf("2. Borrar un grafico existente\n");
            printf("3. Listar accesos\n");
            printf("4. Imprimir grafico por referencia (si es suyo)\n");
            printf("5. Cambiar password del usuario: %s\n", us);
            fflush(stdin);
            scanf("%i", &opc);

            switch (opc)
            {
            case 0:
                break;
            case 1:
                polinomio(us,0,0,0,0,pol);
                getch();
                break;
            case 2:
                borr_gra(us);
                remove("auxiliar.txt");
                break;
            case 3:
                list_acc(us);
                break;
            case 4:
                graf_ref_us(us);
                break;
            case 5:
                cam_pass(us);
                remove("auxiliar.txt");
                break;
            default:
                printf("OPCION INVALIDA...");
                getch();
            }
        } while (opc != 0);
    }
}
int bus_us(char nom[30])
{
    FILE *fp = fopen("login.txt", "rb");
    log_in reg; //variable de tipo log_in
    fseek(fp, 0, SEEK_END); //nos paramos al final
    int n = ftell(fp) / sizeof(log_in); //numero de registros
    rewind(fp); //reiniciamos el puntero
    int cont = 0; //contador

    while (cont <= n - 1)
    {
        fread(&reg.nom, sizeof(log_in), 1, fp); //leemos cada registro

        if (strcmp(reg.nom, nom) == 0 && reg.control != '1')
        {   
            fclose(fp);
            return cont;
        }
        cont++;
    }
    fclose(fp);
    return -1;
}
void newfiles()
{
    FILE *fp = fopen("login.txt", "w"); //creamos el archivo
    fclose(fp); //cerramos el archivo
    return;
}
void encriptacion(char contra[30])
{
    int des = 0; //desplasamiento
    char palcla[30] = ""; //palabra clave
    char contraenc[30] = ""; //contraseÃ±a encriptada
    char val = 0; //valor 
    FILE *fp = fopen("seguridad.gra", "r"); //abrimos el archivo
    int i=0; //contador i
    fread(&des, 4, 1, fp); //leemos el desplazamiento

    for (i = 0; !feof(fp); i++)
    {
        palcla[i] = fgetc(fp); //leemos la palabra clave
    }
    palcla[i]=0; //cerramos la cadena

    //encripta por desplazamiento
    for (int i = 0; contra[i] != 0; i++)
    {
        val = contra[i] + des; 

        contraenc[i] = val;
    }

    //encripta por palabra clave
    for (int i = 0; contra[i] != 0; i++)
    {
        val = contra[i];

        for (int j = 0; palcla[j] != 0; j++)
        {
            if (val == palcla[j])
            {
                contraenc[i] = j;
            }
        }
    }
    fclose(fp); //cerramos el archivo
    strcpy(contra, contraenc);
    return;
}
void login(int opc)
{
    FILE *fp = NULL; //puntero de archivo
    if(opc==0)
        fp = fopen("login.txt", "a"); //modo appened
    else
        fp = fopen("login.txt", "r"); //modo lectura
    log_in reg; //variable de tipo log_in
    char contra[30] = ""; //para almacenar la contraseÃ±a
    char name[30] = ""; //para almacenar el nombre
    char contaux[30] = ""; //auxiliar de contraseÃ±a
    int flag = 0, cont = 0; //contador y bandera
    if (opc == 0)
    {
        do
        {
            clear();
            printf("        Aplicativo - Graficador UTP\n\n");
            printf("Username: ");
            fflush(stdin);
            scanf("%s", name); //leemos el nomnbre
            if (strcmp(name, "root") == 0) //si es root
            {
                cont = 3;
            }   

            printf("Password: ");
            password(contra); //leemos la contraseÃ±a
            if (cont != 3)
            {
                printf("\nEl usuario no es valido para la primera vez...");
                getch();
            }
            else
            {
                encriptacion(contra); //encriptamos la contraseÃ±a
                fwrite(name, sizeof(name), 1, fp); 
                fwrite(contra, sizeof(contra), 1, fp);
                fputc('0', fp);
            }
            cont++;
        } while (cont <= 2);

        fclose(fp);
    }
    else if (opc == 1)
    {
        do
        {
            printf("        Aplicativo - Graficador UTP\n\n");
            printf("Username: ");
            fflush(stdin);
            scanf("%s", name); //leemos el nombre
            flag = bus_us(name); //buscamos el usuario
            printf("Password: "); 
            password(contra); //leemos la contraseÃ±a
            encriptacion(contra); //encriptamos la contraseÃ±a
            fseek(fp, sizeof(log_in) * flag, SEEK_SET); //nos paramos en el registro
            fread(&reg, sizeof(log_in), 1, fp); //leemos el registro
            strcpy(contaux, reg.cont); //guardamos la contraseÃ±a del registro

            if (bus_us(name) != -1)
            {
                if (strcmp(contra, contaux) == 0) //si son iguales
                {
                    fclose(fp);
                    menu(name); //abrimos el menu
                    cont = 5;
                }
                else
                {
                    printf("\nContrase%ca incorrecta..", 164);
                    getch();
                    clear();
                }
            }
            else
            {
                printf("\nUsuario invalido...");
                getch();
                clear();
            }
            //reiniciamos todo
            memset(name,0,30);
            memset(contra,0,30);
            memset(contaux,0,30);
            cont++;
        } while (cont <= 2);
    }

    return;
}
void inicio()
{
    clear();
    FILE *fp=NULL;
    fp=fopen("login.txt","rb");
    if(fp==0)
    {
        fclose(fp);
        fp=fopen("login.txt","wb");
        login(0);
        fclose(fp);
        fp=fopen("login.txt","rb");
        fseek(fp,0,SEEK_END);
        int pos=ftell(fp);
        fclose(fp);
        if(pos==0)
            remove("login.txt");
    }
    else
        login(1);
}
int main(int argc, char *argv[])
{
    inicio();
}
